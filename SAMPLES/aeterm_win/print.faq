Delphi имеет стандартный объект для доступа к принтеру - TPRINTER, 
находящийся в модуле PRINTERS. В этом модуле имеется переменная Printer:Tpinter, 
что избавляет от необходимости описывать свою. Он позволяет выводить данные 
на печать и управлять процессом печати. Правда, в некоторых версиях Delphi 1 
он имеет "глюк" - не работают функции Draw и StrethDraw. Но эта проблема поправима - 
можно использовать функции API. Далее приведены основные поля и методы объекта Printers :
PROPERTY
Aborted:boolean - Показывает, что процесс печати прерван
Canvas:Tcanvas - Стандартный Canvas, как у любого графического объекта. 
Он позволяет рисовать на листе бумаге графику, выводить текст ... . 
Тут есть несколько особенностей, они описаны после описания объекта.
Fonts:Tstrings - Возвращает список шрифтов, поддерживаемых принтером
Handle:HDS - Получить Handle на принтер для использования функций API (см. Далее)
Orientation:TprinterOrientation - Ориентация листа при печати : (poPortrait, poLandscape)
PageHeight:integer - Высота листа в пикселах
PageNumber:integer - Номер страницы, увеличивается на 1 при каждом NewPage
PageWidth:integer - Ширина листа в пикселах
PrinterIndex:integer - Номер используемого принтера по списку доступных принтеров Printers
Printers:Tstrings - Список доступных принтеров
Printing:boolean - Флаг, показывающий, что сейчас идет процесс печати
Title:string - Имя документа или приложения. Под этим именем задание на печать 
регистрируется в диспетчере печати

METODS
AssignPrn(f:TextFile) - Связать текстовый файл с принтером.
Далее вывод информации в этот файл приводит к ее печати. Удобно в простейших случаях.
Abort - Сбросить печать
BeginDoc - Начать печать
NewPage - Начать новую страницу
EndDoc - Завершить печать.

Пример :


Procedure TForm1.Button1Click(Sender: TObject);
Begin
 With Printer do Begin
  BeginDoc; { Начало печати }
  Canvas.Font:=label1.font; { Задали шрифт }
  Canvas.TextOut(100,100,'Это тест принтера !!!'); { Печатаем текст }
  EndDoc; { Конец печати }
 end;
end;


Особенности работы с TPrinter


1. После команды BeginDoc шрифт у Canvas принтера сбрасывается и его необходимо задавать заново
2. Все координаты даны в пикселах, а для нормальной работы необходимы миллиметры 
(по двум очевидным причинам:
 очень трудно произвести разметку страницы в пикселах (особенно если необходима точность), и , 
главное, при изменении разрешающей способности принтера будет изменяться число точек на дюйм, 
и все координаты "поедут".
3. У TPrinter информация о принтере, по видимому, определяются один раз - в момент 
запуска программы (или смены принтера). Поэтому изменение настроек принтера в процессе 
работы программы может привести к некорректной работе, например, 
неправильной печать шрифтов True Type.
Определение параметров принтера через API
Для определения информации о принтере (плоттере, экране) необходимо знать Handle этого принтера, 
а его можно узнать объекта TPrinter - Printer.Handle.
Далее вызывается функция API (unit WinProcs) : GetDevice(Handle:HDC; Index:integer):integer;
Index - код параметра, который необходимо вернуть.
Для Index существует ряд констант :
DriverVersion - вернуть версию драйвера
Texnology - Технология вывода, их много, основные
 dt_Plotter - плоттер
 dt_RasPrinter - растровый принтер
 dt_Display - дисплей
HorzSize - Горизонтальный размер листа (в мм)
VertSize - Вертикальный размер листа (в мм)
HorzRes - Горизонтальный размер листа (в пикселах)
VertRes - Вертикальный размер листа (в пикселах)
LogPixelX - Разрешение по оси Х в dpi (пиксел /дюйм)
LogPixelY - Разрешение по оси Y в dpi (пиксел /дюйм)
Кроме перечисленных еще около сотни, они позволяют узнать о принтере практически все. 
Параметры, возвращаемые по LogPixelX и LogPixelY очень важны - они позволяют произвести 
пересчет координат из миллиметров в пиксели для текущего разрешения принтера. 
Пример таких функций:



Procedure TForm1.GetPrinterInfo; { Получить информацию о принтере }
begin
  PixelsX:=GetDeviceCaps(printer.Handle,LogPixelsX);
  PixelsY:=GetDeviceCaps(printer.Handle,LogPixelsY);
end;

Function TForm1.PrinterCoordX(x:integer):integer; { переводит координаты из мм в пиксели }
begin
 PrinterCoordX:=round(PixelsX/25.4*x);
end;

Function TForm1.PrinterCoordY(Y:integer):integer; { переводит координаты из мм в пиксели }
begin
 PrinterCoordY:=round(PixelsY/25.4*Y);
end;
---------------------------------
GetPrinterInfo;
Printer.Canvas.TextOut(PrinterCoordX(30), PrinterCoordY(55),
 'Этот текст печатается с отступом 30 мм от левого края и '+
 '55 мм от верха при любом разрешении принтера');



Данную методику можно с успехом применять для печати картинок - 
зная размер картинки можно пересчитать ее размеры в пикселах 
для текущего разрешения принтера, масштабировать, и затем уже распечатать. 
Иначе на матричном принтере (180 dpi) картинка будет огромной, 
а на качественном струйнике (720 dpi) - микроскопической.


********************************************************************************************
********************************************************************************************
********************************************************************************************

Следующий пример использует API функцию PrintDlg(), чтобы позволить пользователю выбрать принтер, а так же распечатать две страницы.

Пример:
uses CommDlg;

{$IFNDEF WIN32}
 const MAX_PATH = 144;
{$ENDIF}

procedure TForm1.Button1Click(Sender: TObject);
var
  Pd : TPrintDlg;
  DocInfo: TDocInfo;
begin
  FillChar(Pd, sizeof(Pd), #0); 
  Pd.lStructSize := sizeof(Pd);
  Pd.hWndOwner := Form1.Handle;
  Pd.Flags := PD_RETURNDC;
  if PrintDlg(pd) then begin
    FillChar(DocInfo, sizeof(DocInfo), #0);
    DocInfo.cbSize := SizeOf(DocInfo);
    GetMem(DocInfo.lpszDocName, 32);
    GetMem(DocInfo.lpszOutput, MAX_PATH);
    lStrCpy(DocInfo.lpszDocName, 'My Document');
   {Следующая строка указывает на файл, который надо распечатать }
    lStrCpy(DocInfo.lpszOutput, 'C:\Download\Test.doc');
    StartDoc(Pd.hDc, DocInfo);
    StartPage(Pd.hDc);
    TextOut(Pd.hDc, 100, 100, 'Page 1', 6);
    EndPage(Pd.hDc);
    StartPage(Pd.hDc);
    TextOut(Pd.hDc, 100, 100, 'Page 2', 6);
    EndPage(Pd.hDc);
    EndDoc(Pd.hDc);
    FreeMem(DocInfo.lpszDocName, 32);
    FreeMem(DocInfo.lpszOutput, MAX_PATH);
  end;
end;

********************************************************************************************
********************************************************************************************
********************************************************************************************

Как узнать, поддерживает ли драйвер принтера код PASSTROUGH? Dos-приложения и в Windows 95 используют эту функцию с командой "copy file > lpt1" для передачи текста в буфер принтера.

Хотя Delphi модуль TPrinter облегчает доступ к принтеру, есть случаи, когда вам необходимо спуститься до транспортного уровня общения системы с принтером и передать специфические для устройства управляющие коды. Под 16-битной операционной системой Windows это было так же легко, как открыть порт принтера, но сейчас, к примеру, под Windows NT, непосредственный доступ к аппаратному обеспечению невозможен. Одно из решений проблемы состоит в использовании Windows кода "PASSTHROUGH" для посылки кода непосредственно в принтер. Тем не менее, для использования кода "PASSTHROUGH" необходимо, чтобы это поддерживалось самим драйвером принтера. К сожалению, далеко не все принтеры поддерживают данную характеристику. 

Необходимо отметить, что "PASSTHROUGH" для 32-битных приложений считается устаревшим кодом. Но должно пройти немало лет, прежде чем это умрет окончательно, поскольку это до сих пор используется во многих коммерческих приложениях. 

Приведенный ниже пример не привязан к каким-либо специфическим моделям принтеров. Вам необходимо лишь знать правильную последовательность передачи escape кодов на управляемый вами принтер. Имейте в виду, что вы все еще должны вызывать методы BeginDoc и EndDoc объекта TPrinter. При вызове метода BeginDoc драйвер принтера инициализирует принтер как объект управления, EndDoc - деинициализацирует и извлекает бумагу. При escape вызове принтер может установить текущий режим метрики экрана, если он поддерживает внутреннее масштабирование. Технически вы ничего не должны делать, что могло бы вызвать обнуление памяти принтера или удаление из него бумаги с помощью escape кодов. Другими словами, попытайтесь оставить принтер в том же состоянии, в котором он остался после окончания печати. В основном это касается технически совершенных принтеров, поддерживающих режим Postscript, в стандартных же моделях (TTY) все это не столь существенно, и вы свободны в своих действиях, включая удаление страницы из принтера. 

Пример кода: 

Прежде всего вам необходимо описать структуру буфера, который вы собираетесь посылать. 
Структура буфера определена как слово, содержащее размер буфера и сам буфер, содержащий данные. 

Прежде всего, с помощью escape вызова "QUERYESCSUPPORT" необходимо убедиться, что "PASSTHROUGH" поддерживается драйвером печати. 

И, наконец, ваши данные будут переданы в поток данных принтера. Необходимо также помнить, что в некоторых моделях принтеров (Postscript), вам возможно понадобиться добавить пробелы в начале и в конце передаваемых данных, чтобы отделить ваши данные от данных драйвера печати. 

(Postscript - зарегистрированная торговая марка Adobe Systems Incorporated) 

unit Esc1;

interface

uses
SysUtils, WinTypes, WinProcs, Messages, Classes, Graphics, Controls,
Forms, Dialogs, StdCtrls;

type
TForm1 = class(TForm)
Button1: TButton;
procedure Button1Click(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{ добавляем модуль printers }
uses
Printers;

{$R *.DFM}

{ описываем структуру "PASSTHROUGH" }
type TPrnBuffRec = record
BuffLength : word;
Buffer : array [0..255] of char;
end;


procedure TForm1.Button1Click(Sender: TObject);
var
Buff : TPrnBuffRec;
TestInt : integer;
s : string;
begin

{ Тестируем на предмет поддержки escape кода "PASSTHROUGH" }
TestInt := PASSTHROUGH;
if Escape(Printer.Handle,
QUERYESCSUPPORT,
sizeof(TestInt),
@TestInt,
nil) > 0 then begin

{ Начинаем вывод на печать }
Printer.BeginDoc;

{ Создаем строку для транзитной пересылки }
s := ' Текстовая строка ';

{ Копируем строчку в буфер }
StrPCopy(Buff.Buffer, s);

{ Устанавливаем размер буфера }
Buff.BuffLength := StrLen(Buff.Buffer);

{ Даем команду на транзитную пересылку буфера }
Escape(Printer.Canvas.Handle,
PASSTHROUGH,
0,
@Buff,
nil);

{ Заканчиваем вывод на печать }
Printer.EndDoc;
end;
end;

end.

********************************************************************************************
********************************************************************************************
********************************************************************************************


Под Win16 Вы можете использовать функцию SpoolFile, или 
Passthrough escape, если принтер поддерживает последнее. 
Под Win32 Вы можете использовать WritePrinter. 

'иже пример открытия принтера и записи чистого потока данных в принтер. 
Учтите, что Вы должны передать корректное имя принтера, такое, как "HP LaserJet 
5MP", 
чтобы функция сработала успешно. 

Конечно, Вы можете включать в поток данных любые необходимые управляющие коды, 

которые могут потребоваться. 

uses WinSpool; 

procedure WriteRawStringToPrinter(PrinterName:String; S:String); 
var 
  Handle: THandle; 
  N: DWORD; 
  DocInfo1: TDocInfo1; 
begin 
  if not OpenPrinter(PChar(PrinterName), Handle, nil) then 
  begin 
    ShowMessage('error ' + IntToStr(GetLastError)); 
    Exit; 
  end; 
  with DocInfo1 do begin 
    pDocName := PChar('test doc'); 
    pOutputFile := nil; 
    pDataType := 'RAW'; 
  end; 
  StartDocPrinter(Handle, 1, @DocInfo1); 

  StartPagePrinter(Handle); 
  WritePrinter(Handle, PChar(S), Length(S), N); 
  EndPagePrinter(Handle); 
  EndDocPrinter(Handle); 
  ClosePrinter(Handle); 
end; 

procedure TForm1.Button1Click(Sender: TObject); 
begin 
  WriteRawStringToPrinter('HP', 'Test This'); 
end;

********************************************************************************************
********************************************************************************************
********************************************************************************************


Архитектура печати в Win32 API

Одним из основных достоинств вывода графической информации под Windows является абстрагирование от конкретного устройства вывода, будь то монитор, принтер или, скажем, какой-нибудь другое <экзотическое> устройство. С помощью одних и тех же функций GDI вы можете <рисовать> на любом устройстве. Однако сам процесс <рисования> при этом существенно различается. Это связано с тем, что при печати вы должны учитывать некоторые особенности принтера (например, разрешение), параметры бумаги (ориентация, размер) и проч.

Для печати создается специальный контекст принтера (printer device context). Создать контекст принтера можно с помощью функции CreateDC, которой передается имя принтера. Имя принтера, выбранного текущим пользователем в качестве <принтера по умолчанию>, можно получить, воспользовавшись функцией GetDefaultPrinter, пример использования которой будет приведен ниже. К сожалению, функция GetDefaultPrinter доступна только в операционных системах Windows 2000/XP и старше. Поэтому в версиях ОС Windows 9х и NT 4.0 приходится пользоваться функцией GetProfileString, получающей принтер по умолчанию из системного ini-файла:TCHAR szName[0x200];
GetProfileString(_T("Windows"),_T("Device"),_T(",,,"),szName, 
  sizeof szName/sizeof(TCHAR));


Кроме этого, все доступные принтеры могут быть перечислены с помощью функции EnumPrinters.

Помимо имени принтера, функция CreateDC принимает в качестве параметра указатель на специальную структуру DEVMODE, которая содержит информацию об окружении и настройках принтера. В нее входят упоминавшиеся уже параметры бумаги, количество копий документа, коэффициент масштабирования и т.д. Получить эту структуру можно с помощью функции GetPrinter со вторым информационным уровнем (information level). Информационный уровень определяет тип информации о принтере, получаемой с помощью функции GetPrinter.

Вот примерный код того, как это может быть сделано://Получение хэндла принтера по умолчанию
HANDLE hPrinter = NULL;
DWORD dwSz = 0;
DWORD dwLastErr = -1;
PTSTR pBuf = NULL;
while(!GetDefaultPrinter(pBuf, &dwSz))
{
  dwLastErr = GetLastError();
  if(dwLastErr == ERROR_INSUFFICIENT_BUFFER)
  {
    if(pBuf)
      delete[] pBuf;
    pBuf = new TCHAR[dwSz];
    dwLastErr = ERROR_SUCCESS;
  }
  else
    break;
}

if(dwLastErr == ERROR_SUCCESS && OpenPrinter(pBuf, &hPrinter, NULL))
{

  // Получение структуры PRINTER_INFO_2 для данного хэндла
  LPBYTE pBufpi = 0;
  DWORD dwSzNeeded = 0;
  dwLastErr = -1;
  while(!GetPrinter(hPrinter, 2, pBufpi, dwSzNeeded, &dwSzNeeded))
  {
     dwLastErr = GetLastError();
  if(dwLastErr == ERROR_INSUFFICIENT_BUFFER)
    {
      if (pBufpi)
        delete[] pBufpi;
      pBufpi = new BYTE[dwSzNeeded];
      dwLastErr = ERROR_SUCCESS;
    }
    else
      break;
  }

  if(dwLastErr == ERROR_SUCCESS)
  {
    LPPRINTER_INFO_2 pPI = (LPPRINTER_INFO_2)pBufpi;
    // Работаем со структурой
    HDC hDC = CreateDC(NULL, pPI->pPrinterName, NULL, pPI->pDevMode);
    // Работаем с контекстом
    // Удаляем контекст
    DeleteDC(hDC);
  }

  ClosePrinter(hPrinter);

  if(pBufpi)
    delete[] pBufpi;
}

if(pBuf)
  delete[] pBuf;


Итак, мы успешно создали контекст принтера, однако рисовать на нем пока еще рано.ПРИМЕЧАНИЕ

Есть еще один способ получить контекст принтера. При вызове функций PrintDlg (или PrintDlgEx для Windows 2000/XP) в качестве одного из флагов структуры PRINTDLG можно указать PD_RETURNDC. Тогда после выбора принтера поле hDC этой структуры будет содержать действительный контекст принтера.


Дело в том, что весь вывод на печать организуется специальным процессом - спулером печати, а сам процесс печати разбивается на задания (print job) или документы. Документ - это условное понятие, которое логически определяется функциями StartDoc и EndDoc. При вызове функции StartDoc спулер печати создает расширенный метафайл (enhanced metafile). В него записываются функции GDI, вызванные для данного контекста принтера. Только после закрытия документа вызовом EndDoc расширенный метафайл выводится на принтер.ПРИМЕЧАНИЕ

На самом деле ситуация выглядит более серьезно. :) В самом процессе печати используются несколько компонентов операционной системы: спулер печати (spooler), процессор печати (print processor) и монитор печати (print monitor). Спулер координирует работу остальных компонентов, поддерживает очереди печати и выполняет много другой работы, которая очень подробно описана в DDK. При печати в расширенный метафайл спулер создает специальный файл в системной директории (будем называть его кассетным файлом - spool file), который содержит записи метафайла, тип задания печати и другую информацию. После завершения работы с документом (при вызове функции EndDoc), спулер обращается к процессору печати, который знает, как преобразовывать записи кассетного файла в <сырой> поток данных для принтера. Процессор печати - это просто динамическая библиотека, экспортирующая определенный набор функций, которые описаны в DDK. Добавить свой процессор в систему можно с помощью вызова AddPrintProcessor. Для записи <сырого> потока данных в принтер, процессор использует стандартную функцию GDI - WritePrinter. Эта функция вновь вызывает спулер, однако данные, которые были выданы на принтер, уже не находятся в формате расширенного метафайла, поэтому спулер передает их монитору печати. Монитор печати - это тоже простая DLL, которая экспортирует определенный набор функций, описанных в DDK. Добавить свой монитор можно с помощью функции AddMonitor. Монитор печати предназначен для передачи пакетов данных конкретному драйверу через последовательные или параллельные порты, или через нестандартные сетевые каналы.


Сам документ логически делится на страницы. Страницы определяются вызовом функций StartPage и EndPage. Для успеха вывода на печать эти функции игнорировать нельзя, и вы обязаны их вызвать, даже если документ, по-вашему, не содержит никаких страниц.ПРИМЕЧАНИЕ

Работа функций StartPage и EndPage под Windows NT/2000/XP и Windows 9x существенно отличаются. Под Windows 9x функция StartPage сбрасывает настройки контекста отображения, так что при печати следующей страницы необходимо снова выбирать в контекст кисти, перья и другие объекты GDI. Под Windows NT/2000/XP, выбранные один раз GDI-объекты остаются в контексте принтера на протяжении печати всего документа. Если нужно сбросить контекст отображения, вызовите функцию ResetDC между печатью страниц.


Алгоритм печати с использованием этих функций выглядит следующим образом:
Получаем контекст принтера. 
Формируем задание на печать с помощью вызова функции StartDoc. 
Организуем цикл печати страниц документа. 
Перед печатью каждой страницы вызываем StartPage. 
После печати страницы вызываем EndPage, при этом данные записываются в кассетный файл спулера печати. 
После завершения печати всех страниц вызываем EndDoc, после чего спулер посылает запрос процессору печати, либо AbortDoc, после чего все записи удаляются из кассетного файла данной задачи . 
Освобождаем контекст устройства и другие ресурсы. 

Кажется, все просто. Основная трудность связана с самим рисованием. Вызвано это тем, что, как правило, вам всегда нужно будет масштабировать текст, картинки и фигуры, которые выводятся на принтер. Дело в том, что разрешение принтера в пикселях намного больше разрешения монитора. Например, на моем принтере по умолчанию размер бумаги в пикселях 4476х6714, а у монитора - всего 1024x768. Почувствуйте разницу, как говорится! Мало того, что мониторы еще нескоро достигнут таких разрешений, маловероятно, что у них будут такие же пропорции горизонтальной и вертикальной осей.

Чтобы узнать размеры листа в пикселях, необходимо воспользоваться функцией GetDeviceCaps.phys_x = GetDeviceCaps(hDC, PHYSICALOFFSETX);
phys_y = GetDeviceCaps(hDC, PHYSICALOFFSETY);

phys_cx = GetDeviceCaps(hDC, PHYSICALWIDTH) - 2 * phys_x;
phys_cy = GetDeviceCaps(hDC, PHYSICALHEIGHT) - 2 * phys_y;


Процессы масштабирования текста, фигур и картинок отличаются друг от друга. Для текста, собственно, нужно только изменять высоту шрифта в зависимости от высоты листа бумаги в пикселях.LogFont.lfHeight = phys_cy/koff;


где koff (число строк на листе) я обычно варьирую в диапазоне от 60 до 90. При этом размер шрифта более-менее нормально масштабируется в зависимости от размеров листа бумаги. Если вы хотите, чтобы он зависел от общего коэффициента масштабирования, можно вычислить его по-другому:LogFont.lfHeight = fontHeight*yScale/normal_yScale;


где fontHeight - высота шрифта (от 80 до 200), normal_yScale - коэффициент масштабирования при нормальном размере бумаги, yScale - текущий коэффициент масштабирования.

Коэффициент масштабирования вычисляется по формуле:double yScale = phys_cy/double(real_figure_height);


где real_figure_height - высота фигуры или экрана в пикселях.

Все эти несложные выкладки сильно зависят от решаемой задачи, т.е. выводимого на принтер объекта; не нужно их воспринимать как истинные формулы, просто имейте их в виду

********************************************************************************************
********************************************************************************************
********************************************************************************************



Функция EnumPrinters перечисляет доступные принтеры, серверы печати, домены или провайдеры печати. 
Объявлено в winspool.h; 
#include <windows.h> 


BOOL EnumPrinters(
  DWORD Flags,          //флаги, определяющие способ перечисления принтеров
  LPTSTR Name,          //наименование объекта-принтера
  DWORD Level,          //индекс уровня информации
  LPBYTE pPrinterEnum,  //буфер информации принтера
  DWORD cbBuf,          //размер буфера информации принтера
  LPDWORD pcbNeeded,    //количество переданных или требуемых байтов
  LPDWORD pcReturned    //количество перечисленных принтеров
);

Возвращаемые значения
В случае успеха, функция возвращает не нулевое значение.
В случае неудачи, функция возвращает нулевое значение. Чтобы узнать ошибку, вызвавшую неудачу функции, используйте функцию GetLastError. 
[in] Flags может принимать значения: Значение	Описание
PRINTER_ENUM_LOCAL	Игнорирует параметр Name и перечисляет все локальные принтеры.
PRINTER_ENUM_NAME	Перечисляет принтеры заданные параметром Name. Если Name=NULL, то перечисляет всех доступных провайдеров печати.
PRINTER_ENUM_SHARED	Перечисляет расшаренные принтеры, должен использоваться в паре с другим флагом.
PRINTER_ENUM_DEFAULT	Win 95/98/Me. Возвращает информацию о принтере по умолчанию.
PRINTER_ENUM_CONNECTIONS	Win NT/2000/XP. Возвращает информацию о сетевых принтерах, которые были предварительно подключены.
PRINTER_ENUM_NETWORK	Win NT/2000/XP. Перечисляет сетевые принтеры в домене данного компьютера. Используется при Level=1.
PRINTER_ENUM_REMOTE	Win NT/2000/XP. Перечисляет сетевые принтеры и серверы печати в домене данного компьютера. Используется при Level=1.

Если Level = 4, вы можете использовать только PRINTER_ENUM_CONNECTIONS и PRINTER_ENUM_LOCAL.

[in] Name:
Если Level = 1, Flags = PRINTER_ENUM_NAME и Name не NULL, тогда Name будет указателем на строку, оканчивающуюся нулевым символом, определяющую имя перечисляемого объекта. Может быть именем сервера, домена или провайдера печати.
Если Level = 1, Flags = PRINTER_ENUM_NAME и Name = NULL, тогда функция перечисляет доступные провайдеры печати.
Если Level = 1, Flags = PRINTER_ENUM_REMOTE и Name = NULL, тогда функция перечисляет принтеры в домене пользователя.
Если Level = 2 или 5, тогда Name будет указателем на строку, оканчивающуюся нулевым символом, определяющую имя сервера, принтеры которого должны быть перечислены. Если Name = NULL, тогда функция перечисляет принтеры, установленные на локальном компьютере.
Если Level = 4, Name должно быть NULL. Функция опрашивает локальную машину.
Если Name = NULL и флаги установлены в PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS, будут перечислены принтеры, установленные на локальной машине. Перечислены будут как физически подключенные к данному компьютеру принтеры, так и подключенные сетевые принтеры. 


[in] Level определяет тип структуры данных, указанных pPrinterEnum. Значения 1, 2, 4 и 5 соответствуют структурам данных PRINTER_INFO_1, PRINTER_INFO_2, PRINTER_INFO_4 и PRINTER_INFO_5 соответственно. Для Win 95/98/Me значения могут быть 1, 2 или 5, для Win NT/2000/XP - 1, 2, 4 или 5.

[out] pPrinterEnum - указатель на буфер, принимающий массив структур данных PRINTER_INFO_1, PRINTER_INFO_2, PRINTER_INFO_4 или PRINTER_INFO_5. Каждая структура содержит данные, описывающие доступный объект печати. Буфер должен быть достаточно большим, чтобы вместить заданные массивом членов структур данные. Если буфер мал, то параметр pcbNeeded вернет требуемый размер буфера.

[in] cbBuf - размер в байтах буфера информации, указанного pPrinterEnum.

[out] pcbNeeded - указатель на требуемый размер буфера данных, указанных pPrinterEnum, если значение cbBuf недостаточно.

[out] pcReturned - указатель на число структур данных PRINTER_INFO_1, PRINTER_INFO_2, PRINTER_INFO_4 или PRINTER_INFO_5 (перечисленные принтеры), которые возвращает функция в буфере pPrinterEnum в случае успешного ее выполнения.
Примечания
Если EnumPrinters возвращает структуру PRINTER_INFO_1, в которой определен PRINTER_ENUM_CONTAINER, это указывает, что есть иерархия объектов принтера. Приложение может перечислить иерархию, повторным вызовом EnumPrinters, устанавив значение Name структуры PRINTER_INFO_1 в pName.

Функция EnumPrinters не возвращает информацию о безопасности. Если структуры PRINTER_INFO_2 возвращены в массиве, на который указывает pPrinterEnum, их члены pSecurityDescriptor будут установлены в NULL.

Чтобы получить информацию о принтере по умолчанию, воспользуйтесь функцией GetProfileString с параметрами lpAppName="windows" и lpKeyName="device". В значении lpReturnedString функция вернет имя принтера по умолчанию, файл его драйвера и порт, к которому он подключен